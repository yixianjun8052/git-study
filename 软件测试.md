# 测试行业报告
**就业方向**
功能测试 + web自动化测试
功能测试 + 接口测试
功能测试 + 性能测试

职业能力
    1 用例设计
    2 缺陷管理
    3 抓包分析
    4 数据库操作
    5 环境部署

**测试趋势**
PC端 - 移动端 - 万物互联，自动化，持续集成，敏捷开发，devops，全栈。

敏捷、持续交付、DevOps，导致交付节奏加快，交付节奏加快导致测试压力增加。
持续交付三大支柱：持续集成、自动化测试、部署流水线。

公司应对策略：质量监控 + 发布策略优化 + 自动化测试 + 测试外包（手工）
个人应对策略：手工测试 → 自动化测试 → 测试开发 → 产品架构

# 测试理论
## 测试定义
软件，是计算机控制硬件的工具，软件 = 代码 + 文档 + 数据。

软件质量：功能、易用、兼容、性能、安全。
软件生命周期：需求－设计－编码－测试－运维－废弃。

设计下面两条腿，开发实现一条腿，测试反馈一条腿。
软件开发：需求实现。
软件测试：找缺陷（bug）并跟踪处理，是软件质量保证和风险管理的一个环节。

**软件工程模型**

模型 | 具体
---- | ----
开发模型 | 
瀑布线性开发 | 需求分析-概要设计-详细设计-编码-测试-运维
快速原型开发 | 快速开发产品原型，以应对需求的变动。
阶段增量开发 | 根据需求的稳定性，分阶段、逐步增加稳定的需求来开发。
测试模型 | 
v模型 | 需求分析-概要设计-详细设计-编码-单元测试-集成测试-系统测试-验收测试
双v模型 | 开发v：需求分析-概要设计-详细设计-编码-模块集成-系统集成-交付<br>测试v：需求测试设计-概要测试设计-单元测试设计-单元测试-集成测试-系统测试-验收测试

**测试各阶段目的**
1，研发阶段，侧重多发现缺陷；
2，交付阶段，侧重提高对软件质量的信心；
3，运维阶段，根据用户的使用情况决定缺陷的取舍，是修复，还是作为特性。

**测试原则**
1 测试显示缺陷
2 穷举测试不可行（抽样检查，测试介入和终止）
3 测试尽早介入（测试左移：静态测试之需求评审）
4 缺陷集群
5 杀虫剂悖论：缺陷的抗药性（测试数据的维护更新）
6 测试活动依赖于测试背景（软件服务业，不同行业不同公司有不同测试模型、开发模型）

## 测试分类
测试分类 | 说明
---- | ----
**按测试工具** | 
手工 | 软件页面点点点
自动化 | 使用代码或工具代替手工进行测试，如python+selenium webdrive+unittest/pytest/hytest，以及持续集成测试工具。
**按是否接触代码** | 
黑盒 | 不接触代码，如功能测试。
白盒 | 测代码，如单元测试。
灰盒 | 集成测试、接口测试。
**按测试阶段** | 
单元测试 | UT，对程序最小部分的单元代码进行测试。涉及编码，需要懂开发
集成测试 | IT，对程序不同的单元、模块或子系统合并后进行测试，接口测试。涉及编码，需要懂开发
系统测试 | ST，对整个软件系统测试，涉及功能、性能、接口、兼容性、易用性、界面、安装、安全、文档等测试。<br>由专业测试人员测试，对行业知识有要求（银行、金融、保险、通信）。
验收测试 | α内测、β公测、UAT用户，由用户对系统测试。一般由第三方和用户共同参与。 
**名词** | 
冒烟测试 | 拿到新版本时，先将核心功能的正向用例过一遍，不通过则打回。
回归测试 | 开发修复缺陷后，测试人员确认缺陷是否修复。
功能测试 | 业务功能、安装升级卸载。
性能测试 | 耗费时间、资源占用、并发数，稳定性、负载、压力。
安全性测试 |密码明文或掩码显示、验证、SQL注入（输入' or 1=1 or ''='）、手机短信验证
易用性测试 | 界面、用户体验、上手难易度
兼容性测试 | 不同浏览器不同版本、OS、终端、网络环境等
可维护性测试 | 开发考虑

## 功能测试流程
功能测试总体流程：确定测试需求 → 测试计划 → 设计、评审测试用例 → 搭建测试环境 → 执行用例，判定缺陷 → 推进缺陷 → 总结测试报告
大体可分为四个阶段：确定对象 – 寻找缺陷 – 推进缺陷 – 统计反馈

测试流程	| 操作说明
---- | ----
**阶段一：确定对象（知己知彼）** | 
熟悉项目 | 项目架构、现有成果、人员安排，熟悉软件业务。
确定范围 | 项目测试范围导图（模块-功能）。项目拆分成模块，模块拆分成业务，业务拆分成功能。
编写计划 | 测试需求、资源投入、阶段预期、任务分配、协调帮助
搭建环境 | 物料获取、软件包获取、安装文档
**阶段二：寻找缺陷（用例部分）** | 
设计用例 | 《用例表》。测试用例是实施测试的标准，可防止漏测。需求规则提取，用例设计方法。
评审用例 | 设计人讲解用例设计思路，评审人给予意见和建议。
冒烟测试 | 拿到版本后，先对核心业务功能测试一遍，有问题打回。
执行用例 | 有序按步骤执行用例，比对结果，重现缺陷。
判定缺陷 | 能重现，用例的实际结果与预期不符，不符合需求（多功能、少功能、功能错误、隐性功能未使用、不易使用）。
**阶段三：推进缺陷（缺陷部分）** | 
提交缺陷 | 《缺陷表》：缺陷信息 + 相关信息
定位缺陷 | 1、网络抓包，2、数据库日志（开启日志 set global general_log=1，实时监控 tail -f xx.log，定位后关闭日志。）
跟踪缺陷 | 跟踪缺陷状态，推进修复进度（new/open/fixed/close,rejected/reopen/postpone/abandon）。
回归测试 | 缺陷fix后，有针对性的对缺陷和相关功能进行测试，包括确认修复和是否引发新缺陷。
**阶段四：统计反馈（报告部分）** |
编写报告 | 《测试报告》：资源投入、用例统计、缺陷统计、评估建议
文件存档 | 测试计划、测试用例、测试报告

## 测试计划


## 用例设计
### 页面功能测试思路
页面功能测试，大致可从三个方面着手：1 功能集（基于用户使用习惯的功能集、基于系统的功能集）、2 功能点、3 页面初始化内容。

页面功能测试 | 用例设计适用方法
---- | ----
**＝功能集＝** | 
核心业务线 | 流程分析
基于用户习惯的功能集 | 状态迁移。要考虑用户分类：普通用户、管理员、商家、消费者、平台等。
基于系统的功能集 | 状态迁移
**＝功能点＝** | 
表单 | 等价类、边界值
输入框搜索 | 等价类
选择条件搜索 | 正交试验、判定表
**＝页面初始化内容＝** | 编写sql语句，比对数据库查询结果与页面初始化内容<br>1、确定页面初始化内容：有规律的排列组合；<br>2、确定涉及表：可查看后台表结构，或开启数据库日志记录操作；<br>3、编写select语句，查询结果，注意排序；<br>4、对比查询结果和页面初始化内容。

### 黑盒测试用例设计方法
用例设计谨记：立足需求是基础，深入挖掘业务是关键，灵活应用方法是手段。

用例设计方法 | 适合特征 | 设计要点 | 应用场景
---- | ---- | ---- | ----
流程法 | 业务线 | 画基本流、备选流、异常流<br>每一条流程就是一条用例。 | 购物流程、冒烟测试、安装测试
状态迁移 | 功能组合 | 1、确定功能组合（基于用户/系统）；<br>2、画出功能可达矩阵；<br>3、画深度图或广度图；<br>4、一条开始到结束就是一条用例。 | 购物流程、媒体播放
等价类 | 集合范围<br>解决枚举 | 明确输入规则，划分等价类（有效、无效），抽样选取数据。<br>有效等价类全覆盖，无效等价类一个一条用例。<br>用例估算：有效等价类最高数 + 所有无效等价类 | 需要大量数据测试输入，但没法枚举。<br>如输入框、下拉列表、单选复选框
边界值 | 集合范围<br>解决边界 | 确定边界点：上点、内点、离点，7点优化为5点，共5条用例。<br>上点：边界上的点，不考虑区间开闭。必选。<br>离点：距离上点最近的点。开内闭外，4点优化为2点。<br>内点：范围内的点，建议中间范围。必选。 | 有边界范围的输入框类。<br>如大小、尺寸、重量、最大、最小、至多、至少等计量词。
判定表 | 条件制约结果 | 画判定表：条件桩、动作桩，条件项、动作项<br>一条判定链就是一条用例。 | 适用于条件较少的情况。
正交表 | 多因素多水平 | 确定各因素及其各自水平，利用软件制作正交表。<br>水平不同时往大了取。 | 商品筛选

综合使用各类黑盒测试用例设计方法的通用原则。
（1）基于业务流清晰的系统，场景法贯穿整个测试案例过程，并可在此基础上综合应用各种测试方法。
（2）等价类划分法较其他方法往往优先使用，可高效筛选测试用例，将无限测试变为有限测试。
（3）边界值分析法在任何情况下都应被考虑，它是挖掘缺陷的最有效手段之一。
（4）各种测试中，均可借助错误推测法扩充测试用例，进一步将测试高手的智慧和经验转为可视化成果。
（5）因果图法和决策表法尤为相似，更适用于系统中的各输入条件及输出结果之间存在关系的情况。
（6）正交试验法在参数配置类及兼容性的测试用例设计中，简单易行、优势显著。
（7）上述所有测试进行中，依据需求及业务逻辑，检查已设计出测试用例的逻辑覆盖程度，若尚未达到覆盖标准，则需继续补充完善测试用例。

#### 穷举法
穷举法，是在一个可能存在可行状态的状态全集中，依次遍历所有元素并逐一判断是否为可行状态的一种方法。

该方法数据量甚大、重复性较强，且耗时费力，不推荐。

#### 等价类划分法
等价类划分法，是将程序所有可能的输入进行合理分类，再从每一个分类中选取少数具有代表性的数据作为测试用例，从而开展测试，其中的“合理分类”即“划分等价类”。之所以分类“等价”，是由于从划分好的分类中，任意选取一条数据都能代表其他的数据执行测试，它们之间选取是等价的。

该方法广泛应用于各项测试中，既能大量减少测试工作量，又能提高测试的有效性。

此法中，“如何划分等价类”尤为关键。等价类可分为有效等价类和无效等价类两方面，阐述如下。
（1）有效等价类：符合需求说明的，合理的输入数据的集合。
（2）无效等价类：不符合需求说明的，无意义的输入数据的集合。

等价类划分法的应用步骤，如下。
（1）依据常用方法划分等价类。
（2）为等价类表中的每一个等价类分别规定一个唯一的编号。
（3）设计一个新用例，使它能够尽量多覆盖尚未覆盖的有效等价类。重复该步骤，直到所有有效等价类均被用例所覆盖。
（4）设计一个新用例，使它公覆盖一个尚未覆盖的无效等价类。重复该步骤，直到所有无效等类均被用例所覆盖。

考虑点
长度：长度范围内，小于范围最小值、大于范围最大值
类型：数字（自然数、负数、小数）、英文字母、字符、汉字、空
规则：
是否合理
大小写
是否重复
是否过期
首尾空格
复制粘贴

#### 边界值分析法
边界值分析法，是对输入或输出的边界值进行测试的一种测试方法。它不是从一个等价类中任选一值作为代表，而是选一个或几个值，使得该等价类的边界值成为测试关注目标。通常作为对等价类划分法的补充，其测试用例往往来自等价类的边界。

边界值的分析，不仅关注输入条件，它还根据输出的情况（即按输出等价类）设计测试用例。

边界值分析的应用步骤如下：
首先，确定边界。通常，输入或输出等价类的边界即为着重测试的边界区域。
其次，选取等于、刚刚大于或刚刚小于等价类边界的值作为边界值测试数据，而并非选取等价类中的典型值或任意值。
（1）输入条件规定了值的范围，则应取刚达到这个范围的边界值以及刚刚超过这个范围边界的值作为测试边界值。
（2）输入条件规定了值的个数，则应取最大个数、最小个数及比最大个数多一个、比最小个数少一个的数作为测试边界值。
（3）输入域或输出域是有序集合（如有序表、顺序文件等），则应取集合中的第一个和最后一个元素作为测试边界值。
（4）分析需求规格说明书，找出其他可能的边界条件。

类型 | 边界值 | 实例
---- | ---- | ----
数字 | 最大/最小 | 某保险系统的投保页面中，仅可针对年龄在 5～50 岁的人群进行投保，现进行投保年龄测试。
字符 | 首位/末位 | 针对 ASCII 中的字符 “A"~"Z" 进行测试，则其边界值对应的为”＠、\[、A、Z“。
位置 | 上/下 | 某列表中最多显示 20 条记录，现进行删除操作测试。
速度 | 最快/最慢 | 某登录页面的验证码功能，当该验证码停留 10s 未进行验证码输入时，验证码过期。现进行验证码过期时长测试。
尺寸 | 最短/最长 | 某视频监控系统，可监控的视角范围为 1～20ｍ 的区域，现进行该监控范围的测试。
重量 | 最轻/最重 | 重量在 10.00～50.00kg 范围内的邮件，其邮件计算公式为……，则其重量的边界值为 9.99,10.00,50.00,50.01。
空间 | 空/满 | 某 U 盘容量为 1GB，现针对该 U 盘容量进行测试。

#### 决策表法
判定表，又称作决策表，为决策表法的核心，是分析和表达多逻辑条件下执行不同操作情况的有效工具。

因此，决策表法是一种能够将复杂逻辑关系和多条件组合情况表达得较为明确的方法，适用于程序中输入输出较多或输入与输出之间相互制约条件较多的情况。

综合所有黑盒测试方法来讲，基于决策表法的测试是最严格，最具有逻辑性的。

决策表模块图

 | 
 ---- | ----
 条件桩 | 条件项
 动作桩 | 动作项

条件桩：为问题的所有条件的集合，包含了各种条件，其中各条件次序无严格限制。
条件项：为问题的所有条件的各种取值的集合，包含了左侧条件桩中各种条件的各种取值的组合，其中各条件次序无严格限制。
动作桩：为问题的所有可采取操作集合，包含了各种可采取的操作，其中各操作次序无严格限制。
动作项：为针对条件茂的各种组合的取值情况下，应该采取的对应操作。
任何一个条件组合的特定取值及其相应要执行的操作称为规则。

决策表法应用步骤
（1）列出所有的条件桩和动作桩；
（2）确定规则的个数；
（3）填入条件项；
（4）填入动作项；
（5）简化决策表，合并类似规则或相同动作。（无关条件用”－“表示）

#### 正交试验法
正交试验法，即使用事先已创建好的表格——正交表，来安排试验并进行数据分析的一种科学试验设计方法。
换言之，正交试验法即提供一个或一系列表格，表格中已经设计好了用例编号和规则，仅参照表格内容直接套用即可。

常用于参数配置或兼容性测试中。

常用正交表有 ![[常用正交表.png]]
说明：“L”表示正交表，下标“9”表示该正交表可构成的最大用例数，上标“4”表示最大分类数，即因素数，“3"表示各分类下的最大元素数，即水平数。

在遇到因素和水平不是完全按照正交表时，可选择将多水平因素的多出来的选择进行合并，将少水平因素中的任意一个水平重复使用，再套用正交表，之后再将合并的水平进行拆分。

#### 错误推测法
错误推测法，基于**经验和直觉推测**软件中容易产生缺陷功能、模块，及各种业务场景等，并依据推测逐一进行列举，从而更有针对性的设计测试用例。

纵观众多的软件系统，尽管功能不同，业务各异，但归根结底都离不开最基本的“增删改查”功能。现针对这四个最基本功能汇总通用测试点，积累经验。

考虑角度：功能（正确提交、错误提交）、字段（限制规则、特殊标识、唯一性、自动产生字段）、提示信息、操作权限

增删改查 | 测试点汇总
---- | ----
新增 | 1、正确输入页面各字段信息，验证系统是否提示操作成功，且相关模块和数据库中是否添加了相应的记录。<br>2、错误输入页面中某个或某些字段信息，验证系统是否提示操作失败及失败原因，且相关模块和数据库中是否未添加相应的记录。<br>3、验证界面中各字段的名称及控件类型显示是否同需求规格说明书，避免出现丢失字段或有多余字段，及字段不正确的情况。<br>4、验证各字段的字段规则控制是否合理，如邮箱格式，当输入的类型不符合格式要求时，给出相应的提示。<br>5、验证必填项字段是否有 \* 等特殊提示标识。<br>6、验证必填项字段是否控制正确，不填写时，给出必须填写提示信息。<br>7、对于有唯一性限制的字段，验证唯一性控制是否准确，如使用已注册过的邮箱再次注册，给出已注册的提示。<br>8、验证各按钮功能是否正确，如提交、重置、取消等。<br>9、验证正确、错误等各类不同输入情况下，相应产生的提示信息描述准确、清晰。<br>10、验证新增的操作权限是否控制正确，有权限人员可进行新增操作，反之则不能。如添加图片已添加限定张数后，“新增”按钮置灰显示或不再显示；再如作业提交超过截止时间后，则不能再提交。<br>11、当有自动产生的字段时，验证新产生的各项字段显示正确、功能正确。如勾选”显示高级用户设置选项“复选框后，即可打开高级字段界面。
删除 | 1、选择一条记录进行删除，验证系统是否提示操作成功，且相关模块和数据库中是否删除了相应的记录。<br>2、选择一条记录未进行删除，验证相关模块和数据库中是否删除了相应的记录。<br>3、进行删除操作，验证是否弹出确认删除提示框，且支持确定（即删除）和取消（即不删除）操作。<br>4、验证删除单条记录、多条记录及全部记录的功能是否正确。<br>5、当删除操作为软删除（即未真正删除，仅为前台无法看见，但仍存放于后台或其他位置）时，验证软删除后是否可恢复被删除的记录。<br>6、多记录分页显示情况下，验证删除功能是否正确，如当最后一页仅有一条记录时，删除此记录，是否会报错且是否会自动将页码定位于前一页。<br>7、验证删除的操作权限是否控制正确，有权限人员可以进行删除操作，反之则不能。如普通用户 A 新增的帖子，只有 A 及管理员有权限删除，而其他普通用户不具备删除权限。<br>8、验证是否支持批量删除功能。
修改 | 1、进入修改界面，验证界面显示出的内容是否同新增时填写的信息，且内容与字段准确对应。<br>2、进入修改界面，验证界面中部分字段是否为只读方式显示，限制进行修改，如工单流水号等不支持修改。<br>3、在修改界面中，进行修改操作且成功保存后，验证系统是否提示操作成功，且相关模块和数据库中是否显示为修改后的记录。<br>4、其他测试内容基本同新增功能类似，如必填项字段验证、字段规则验证、唯一性验证、修改权限验证等。
查询 | 1、查询时，输入的查询条件为数据库中存在的记录，验证是否能正确查出。<br>2、查询时，输入的查询条件为数据库中不存在的记录，验证是否无法查出。<br>3、验证界面中查询字段的设置是否同需求规格说明书，避免出现丢失字段或有多余字段及字段不正确的情况。<br>4、查询不同类型的内容（数据库中存在相应数据），验证是否能正确查出。<br>5、查询条件有条数限制时，测试查询边界条数是否正确，如：一次查询可显示 5 条记录，则需对 4 条、5 条、6 条情况进行测试。<br>6、验证单条件查询、多条件组合查询功能是否正常。<br>7、验证无条件查询（即不输入条件）时，是否默认显示所有记录。<br>8、验证是否支持模块查询。<br>9、查询条件中存在空格时，验证是否过滤空格。<br>10、查询条件中输入特殊字符时，验证是否处理，如 ＆。<br>11、验证查询结果分页显示是否正确，且各页查询结果是否均可正确查看。<br>12、验证清空查询条件按钮功能是否实现，且功能正常。

#### 场景法
系统大多是由事件来触发控制流程的，每个事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果形成了不同的事件流。
事件流即一个事件及其所引发的后续处理。

”场景“，可理解为由”哪些人、什么时间、什么地点、做什么以及如何做“等要素组成的一系列相关活动，且场景中的活动还能由一系列场景组成。

场景法，是通过使用”场景“对软件系统的功能点或业务流程进行描述，即针对需求模拟出不同的场景进行所有功能点及业务流程的覆盖的一种方法。
适用于解决业务流程清晰的系统或功能。

通常，场景法由基本流和备选流两部分构成。
基本流：经过用例的最简单路径，即无任何差错，程序从开始直接执行到结束的流程。通常，一个业务仅存在一个基本流；且基本流仅有一个起点和一个终点。
备选流：为除基本流之外的各支流，于某个特定条件下执行，然后重新加入基本流；亦可开始于另一备选流；亦可终止用例而不再加入到基本流。
![[场景法构成.png]]
上图中可组合成多个不同的场景，如下：
场景1：基本流
场景2：基本流 备选流1
场景3：基本流 备选流1 备选流2
场景4：基本流 备选流3
场景5：基本流 备选流3 备选流1
场景6：基本流 备选流3 备选流1 备选流2
场景7：基本流 备选流3 备选流4
场景8：基本流 备选流4

场景法应用步骤：
（1）分析需求，确定软件的基本流和各项备选流。
（2）依据基本流和各项备选流，生成不同的场景。
（3）针对生成的各场景，设计相应的测试用例。
（4）重新审核生成的测试用例，去年多余部分；并针对最终确定的测试用例，设计测试数据。

注意，”用户退出系统“这个备选流可在任意步骤中发生，故用未知数 x 表示。

### 用例表设计

编号 | 标题 | 测试模块 | 优先级 | 前置条件 | 测试数据 | 操作步骤 | 预期结果
---- | ---- | ---- | ---- | ---- | ---- | --- | ----
项目简称\_模块简称\_序列编号 | 预期执行结果（测试点） | 模块名 | P0 核心正向<br>P1 核心逆向<br>P2 普通正向<br>P3 普通逆向 | 用例执行前置环境 | 各项输入数据 | 执行步骤 | 前台、后台、数据库等显性和隐性输出

- 黑盒测试的用例设计，总体上考虑：
    - 输入：可见输入、不可见输入
    - 处理：正常操作/异常操作+正常数据/异常数据
    - 输出：前台可见输出、后台可见输出、数据库不可见输出

### 功能分析与用例积累
网页表单分析和用例设计

表单项 | 限制条件
---- | ----
文本输入框 | 长度<br>数据类型：数字/字母/汉字/特殊字符<br>组成规则：以xx开头/结尾<br>是否可为空<br>是否可重复<br>空格（全前中后）<br>大小写区分
账号框 | 
密码框	| 
确认密码 | 与密码一致
验证码 | 空、正确、已存在、过期、错误
邮箱 | 格式
手机 | 地区码 + 前缀 + 后缀
电话 | 
年月日 | 1/3/5/7/8/10/12月有31号，4/6/9/11有30号<br>闰年2月29号，平年2月28号
地区住址 | 
单选按钮 | 
多选框 | 
下拉单选 | 	
下拉多选 | 
下拉级联选择 |
选择文件 | 
文本域 | 
功能按钮 | 

条件组合搜索（+ 自定义价格）：正交试验 + 等价类边界值
价格范围输入框：前框输入的价格必须要小于后框

## 缺陷
### 缺陷表设计

设计项 | 说明
---- | ----
**=缺陷描述=** | 
缺陷标题 | 
复现环境 | 
复现步骤 | 
预期结果 | 
实际结果 | 
截图、日志、消息包等附件 | 
**=提交描述=** | 
缺陷编号 | 
缺陷类型 | 功能问题，界面UI问题，兼容性问题，易用性问题，数据库问题，性能问题，改进建议。
严重程度 | 严重（主功能），一般（次要功能），微小（易用性，界面），建议（建议性问题）。
修复优先级 | 0（24h内修复），1（发布前必须修复），2（可以在下个版本中修复）。
缺陷状态 | 新提交 new，开发修复中 open，开发修复完成 fixed，回归测试通过 closed；<br>回归测试失败 reopen,推迟 postpone,开发认为不是缺陷 rejected,测试确认不是缺陷 abandon。
提交人、时间 | 
提交给谁 | 

### 定位缺陷
缺陷产生原因：需求原因、设计原因、编码原因、运行环境原因
网络抓包
日志文件

## 测试报告

# 功能自动化测试
总体思路：编写测试点函数模块，编写通用功能函数模块，编写测试用例模块，编写用例套件模块，执行用例并输出测试报告，即时通知。
工具：python + selenium webdriver + hytest/pytest/unittest

## 自动化测试脚本编写
python + selenium webdriver

## 自动化测试框架
框架作用：
1. 批量编写脚本
2. 批量执行脚本
3. 自动生成测试报告
4. 数据驱动，测试数据与脚本分享

框架基本结构：用例模块、测试点函数模块

单元测试框架 [[unittest]] 和 [[pytest]] 也可以用来做 Web 自动化测试。

## Page Object 设计模式
Page Object 是 UI 自动化测试项目开发实践的最佳设计模式之一，它的主要特点体现在对界面交互细节的封装上，使测试用例更专注于业务的操作，从而提高测试用例的可维护性。

当为 Web 页面编写测试时，需要操作该 Web 页面上的元素。然而，如果在测试代码中直接操作 Web 页面上的元素，那么这样的代码是极其脆弱的，因为 UI 会经常变动。

page 对象的一个基本经验法则是：凡是人能做的事，page 对象通过软件客户端都能做到。
因此，它应当提供一个易于编程的接口，并隐藏窗口中底层的部件。当访问一个文本框时，应该通过一个访问方法（Accessor Method）实现字符串的获取与返回，复选框应当使用布尔值，按钮应当被表示为行为导向的方法名。page 对象应当把在 GUI 控件上所有查询和操作数据的行为封装为方法。

一个好的经验法则是，即使改变具体的元素，page 对象的接口也不应当发生变化。

尽管该术语是 page 对象，但并不意味着需要针对每个页面建立一个这样的对象。例如，页面上有重要意义的元素可以独立为一个 page 对象。经验法则的目的是通过给页面建模，使其对应用程序的使用者变得有意义。

在自动化测试开发中应遵循这种设计模式来编写代码。应该遵循以下原则进行开发：
- Page Object 应该易于使用。
- 有清晰的结构，如 PageObjects 对应页面对象，PageModules 对应页面内容。
- 只写测试内容，不写基础内容。
- 在可能的情况下防止样板代码。
- 不需要自己管理浏览器。
- 在运行时选择浏览器，而不是类级别。
- 不需要直接接触 Selenium

Page Object 的设计思想上是把**元素定位与元素操作进行分层**，这样带的来最直接的好处就是当元素发生变化时，只需维护 page 层的元素定位，而不需要关心在哪些测试用例当中使用了这些元素。在编写测试用例时，也不需要关心元素是如何定位的。

编写思路：从测试用例，到页面 page，再到通用 basepage。

实现案例：以百度搜索为例
第1步，测试用例中调用方法
关键：测试用例中，只包含 测试步骤 和 断言。
在测试用例中，使用 BaiduPage 类及它所继承的父类中的方法。
在每个测试用例中为 BaiduPage 类传入驱动，这样就可以轻松地使用它封装的方法来设计具体的测试用例了。这样做的目的就是在测试用例中消除元素定位。如果你要操作百度输入框，那么只需调用 search_input()方法并传入搜索关键字即可，并不需要关心百度输入框是如何定位的。
当需要用到哪个 Page 类时，只需将它传入浏览器驱动，就可以使用该类中提供的方法了。
```PYTHON
import unittest
from time import sleep
from selenium import webdriver
from baidu_page import BaiduPage

class TestBaidu(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        
    def test_baidu_search_case(self):
        page = BaiduPage(self.driver)
        page.open()
        page.search_input("selenium")
        page.search_button()
        sleep(2)
        self.assertEqual(page.get_title(), "selenium_百度搜索")
        
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
        
if __name__ == '__main__':
    unittest.main(verbosity=2)
```

第2步，创建 baidu_page.py 文件
创建 BaiduPage 类继承 BasePage 类，定义 url 变量，供父类中的 open()方法使用。在__init__()初始化方法中接收参数driver并赋值给self.driver。封装 search_input()方法和 search_button()方法，调用父类方法定位元素，并操作元素。这里的封装只针对一个页面中可能会操作到的元素，原则上是一个元素封装成一个方法。当元素的定位方法发生改变时，只需维护这里的方法即可，而不需要关心这个方法被哪些测试用例使用了。
```PYTHON
from base import BasePage

class BaiduPage(BasePage):
    """百度 Page 层，百度页面封装操作到的元素"""
    url = "https://www.baidu.com"
       
    def search_input(self, search_key):
        self.by_id("kw").send_keys(search_key)
        
    def search_button(self):
        self.by_id("su").click()
```

第3步，创建 base.py 文件
创建 BasePage 类作为所有 Page 类的基类，封装一些在做自动化时经常用到的方法，如打开网址、定位元素、获取页面信息、执行js等。
```PYTHON
class BasePage:
    """
    基础 Page 层，封装一些常用方法
    """
    
    def __init__(self, driver):
        self.driver = driver
    
    # 打开页面。如果 url 参数为None，则默认打开子类中定义的 url。稍后会在子类中定义 url 变量。
    def open(self, url=None):
        if url is None:
            self.driver.get(self.url)
        else:
            self.driver.get(url)
    
    # id 定位
    def by_id(self, id_):
        return self.driver.find_element_by_id(id_)
    
    # name 定位
    def by_name(self, name):
        return self.driver.find_element_by_name(name)
    
    # class 定位
    def by_class(self, class_name):
        return self.driver.find_element_by_class_name(class_name)
    
    # XPath 定位
    def by_xpath(self, xpath):
        return self.driver.find_element_by_xpath(xpath)
    
    # CSS 定位
    def by_css(self, css):
        return self.driver.find_element_by_css_selector(css)
    
    # 获取 title
    def get_title(self):
        return self.driver.title
    
    # 获取页面 text，仅使用 XPath 定位
    def get_text(self, xpath):
        return self.by_xpath(xpath).text
    
    # 执行 JavaScript 脚本
    def js(self, script):
        self.driver.execute_script(script)
```

### poium
poium 是一个基于 Selenium/appium 的 Page Object 测试库，最大的特点是简化了 Page 层元素的定义。支持 pip 安装。
项目地址：https://github.com/defnngj/poium。

1 ．支持的定位方法
poium 支持 8 种定位方式。
```PYTHON
from poium import Page, PageElement

class SomePage(Page):
    elem_id = PageElement(id_='id')
    elem_name = PageElement(name='name')
    elem_class = PageElement(class_name='class')
    elem_tag = PageElement(tag='input')
    elem_link_text = PageElement(link_text='this_is_link')
    elem_partial_link_text = PageElement(partial_link_text='is_link')
    elem_xpath = PageElement(xpath='//*[@id="kk"]')
    elem_css = PageElement(css='#id')
```

2．设置元素超时时间
通过 timeout 参数可设置元素超时时间，默认为 10s。
```PYTHON
from poium import Page, PageElement

class BaiduPage(Page):
    search_input = PageElement(id_='kw', timeout=5)
    search_button = PageElement(id_='su', timeout=30)
```

3 ．设置元素描述
当一个 Page 类中定义的元素非常多时，必须通过注释来增加可读性，这时可以使用describe 参数。describe 参数并无实际意义，只是增加了元素定义的可读性。
```PYTHON
from poium import Page, PageElement

class LoginPage(Page):
    """
    登录 Page 类
    """
    username = PageElement(css='#loginAccount', describe="用户名")
    password = PageElement(css='#loginPwd', describe="密码")
    login_button = PageElement(css='#login_btn', describe="登录按钮")
    user_info = PageElement(css="a.nav_user_name > span", describe="用户信息")
```

4 ．定位一组元素
当我们要定位一组元素时，可以使用 PageElements 类。
```PYTHON
from poium import Page, PageElement

class ResultPage(Page):
    # 定位一组元素
    search_result = PageElements(xpath="//div/h3/a")
```

使用 poium 重写 baidu_page.py。
创建 BaiduPage 类，使其继承 poium 库中的 Page 类。调用 PageElement 类定义元素定位，并赋值给变量 search_input 和 search_button。这里仅封装元素的定位，并返回元素对象，元素的具体操作仍然在测试用例中完成，这也更加符合 Page Object 的思想，将元素定位与元素操作分层。
```PYTHON
from poium import Page, PageElement

class BaiduPage(Page):
    """百度 Page 层，百度页面封装操作到的元素"""
    search_input = PageElement(id_="kw")
    search_button = PageElement(id_="su")
```

在测试用例中的使用如下。
首先导入 BiaduPage 类，传入浏览器驱动。然后，调用 get()方法访问 URL，该方法由Page类提供。接下来调用BaiduPage类中定义的元素对象，即search_input和search_button ，实现相应的输入和单击操作。
```PYTHON
from baidu_page import BaiduPage

class TestBaidu(unittest.TestCase):

    …
    def test_baidu_search_case1(self):
        page = BaiduPage(self.driver)
        page.get("https://www.baidu.com")
        page.search_input = "selenium"
        page.search_button.click()
        
    …
```

# 测试相关技能
## linux
linux在软件测试中的作用：
    搭建测试环境
    定位问题：利用linux日志文件定位问题，| + grep + awk + sed
    获取页面数据，如预期结果：curl + | + grep + awk + sed
    压力测试，控制并发数：while + jobs + grep + curl + & + sleep
    监控进程性能：ps + while

1  搭建测试环境

作为服务器操作系统，安装应用软件，搭建测试环境。

2 帮助缺陷定位
查看日志（tail -f xxx.log）可以帮助缺陷定位。
	linux日志：
	后台日志（测试对象运行产生的日志）：
	应用服务器（nginx）日志：/data/server/nginx/logs/access.log

状态码
```shell
# 统计状态码出现情况：
awk '{print $9}' /xx/nginx/logs/access.log | sort | uniq -c

# 查看状态码为 404 的行
awk '$9==404' /xx/nginx/logs/access.log
awk '$9~/404/' /xx/nginx/logs/access.log

# 查看状态码为 404 的前10行、后10行、前后10行
grep -B 10 " 404 " /xx/nginx/logs/access.log
grep -A 10 " 404 " /xx/nginx/logs/access.log
grep -C 10 " 404 " /xx/nginx/logs/access.log
```

找出访问量最高的ip、页面地址
```shell
awk '{print $1}' /xx/nginx/logs/access.log | sort | uniq -c | sort -nr | head -1

awk '{print $7}' /xx/nginx/logs/access.log | grep -Ev 'gif|jpg|png|ico|js|css' | sed 's/?.*//g' | sort | uniq -c | sort -nr | head -1


# 查找通过 ssh 22 号端口建立连接的网络连接地址总数
netstat -tn | grep "10.0.2.15:22" | awk '{print $5}' | awk -F : '{print $1}' | sort | uniq | wc -l
```

压力测试：监控并发数
```shell
while true;do count=$(jobs -l | grep "Running" | wc -l);[ $count -le 10 ] && { time curl https://testerhome.com/topics/30203 &>/dev/null & } || echo $count waiting;sleep 0.1;done
```

监测指定进程的cpu、mem占用情况
```shell
while true;do ps -o %cpu,%mem -p 1241 | tail -1;sleep 1;done
```

3 可用来获取预期结果。
例子：获取 testerhome 社区首页中每个帖子的点赞数
思路：首先获取每个帖子页面的topic后面的数字，即获取得了相应的url，再进行每个帖子页面获取赞。
```shell
topic_num=`curl -s https://testerhome.com/topics/ | grep -o 'href="/topics/[0-9]*"' | grep -o "[0-9]*"`;for id in $topic_num;do url=https://testerhome.com/topics/$id;zan=`curl -s $url | grep -m1 'data-type="Topic"' | awk -F '<a title="赞" data-count="|" data-state' '{print $2}'`;echo $url '点赞数' $zan;done | awk -F '.com' '{print $NF}'
```
## 数据库
数据准备：验证翻页功能，procedure + while + insert into
数据查询：查询结果验证、查询效率，select、explain
定位问题：利用数据库日志文件定位问题 /data/server/mysql/data/xx.log,xx.err，| + grep + awk + sed
数据安全：SQL注入

## python
## 网络抓包
# 测试应聘
## 简历制作

## 项目经验
中软国际－华为外包 MediaX3600融合会议

“融合会议”业务是面向政企客户提供的多媒体会议服务，集语音会议、标清视频会议、高清视频会议、WEB会议及数据协作等功能于一体，用户可通过PC、IPAD、手机等多种终端设备，随时随地加入高品质的多媒体融合会议，开展跨地域协作、培训、沟通，有效提升效率、降低企业成本。

组网：OMU/MediaX/CSCF/MRFC/MRFP/MCU/HSS/CCF/SPG2800/SMTP/RSE
主会议media、会话控制cscf、媒体资源mrfc/mrfp、视频资源mcu、计价ccf、用户分发hss、rse录播服务器、邮件服务器

架构：IIS + JSP，V300R006SPC100-->V300R008-->V500

融合会议平台提供以下功能：
1、会议管理：用户可轻松便捷的预定会议、查询会议、修改会议、取消会议；
2、会议通知：会议通知可通过邮件、短消息等方式进行推送;
3、会议控制：会议管理员可邀请与会者、强踢与会者、与会者静音、延长会议、关闭会议、会议锁定、会议解锁、会议录音;
4、入会模式：自动接入会议、被动接入会议；
5、多终端入会：个人电脑、平板电脑、IP话机、手机、高清智真终端等多终端同时加入会议。

会议流程：
预定会议-->会议管理-->会议通知-->入会-->会控（入会离会控制-角色发言控制-数据共享控制、视频画面控制）-->结束会议-->会后回看（点播，查看统计），升级前预定会议、升级后开会

业务流
注册
登录
建会：类型（实时会议、定时会议、周期会议），会议主题、方数、时长，会议通知（邮件或短信）（会议号、接入码、接入号、网址）
入会：主动入会（会议列表一键入会，会议号和接入码入会、拨打会议接入号语音导航入会）、被动入会（被邀请入会）
会控：与会者邀请和删除、退出和结束会议、会议锁定、会议闭音、与会者闭音、与会者列表刷新、显示发言人信息、延长会议、主席申请、挂断和重拨与会者、举手、指定广播会场、自由选看会场
会后：点播

预定会议失败：资源不足，参数错误
召开会议失败：资源不足，参数错误
主动入会失败：资源不足，鉴权失败，会议未召开或已结束
邀请入会失败：资源不足，用户忙/无应答/拒接/不可达

建立音频通话，通话中闭音，音频转视频
建立视频通话，通话中暂停视频，视频转音频

工作职责：外包项目
1、镜像升级测试：升级回退测试，升级前后业务流程测试，前后数据比对，维护系统正常升级；
2、测试环境搭建：获取现网镜像，搭建服务器测试环境（OMU/MEDIAX/CSCF/MRFP/MCU/HSS/CCF/RCS/EMAIL/SMS），配置各网元数据；
3、执行并补充测试用例，跟踪处理缺陷，撰写测试报告；
4、补丁测试。

缺陷：
严重：某镜像升级后某SIP消息错误，导致拨打会议接入号进入会议失败。新补丁修复。

升级测试测什么
安装测试：确保修改过的文件存放在正确的位置，检查文件大小与旧版本的不同，比较工具beyondcompare
数据库测试：系统升级伴随着数据库脚本的更新。升级前备份数据库，升级后查看升级日志，检查库中被修改的记录是否正确
应用测试：检查现网数据是否在升级后，仍然能够被正确的展现和使用，最后执行业务流程测试看系统是否能正常运行
文档测试：验证相关的版本说明或安装手册等文档是否和系统升级相匹配

升级测试步骤：
1. 获取现网数据：版本、环境、数据库、镜像文件	俄罗斯、乌干达、移动双跨、湖北移动、印尼
2. 还原现网环境：
3. 升级前测试：
    - 业务功能测试：保证系统正常运行
    - 备份数据库
    - 获取或配置相关文件：ccf话单等
4. 按照升级文档进行升级测试：验证按照升级测试文档是否能正常升级
5. 升级后测试
    - 业务流程测试：保证升级后系统正常运行
    - 数据库比较：
    - 相关文件比较：话单
6. 回退测试：验证按照升级测试文档是否能正常回退

## 面试交流
解决问题：如何说服面试官，我能胜任这份工作？
思路：①基本专业能力+项目经验=胜任，②扩展能力=做好，③职业规划=稳定性，④服从性，⑤矛盾处理

给一个软件，怎么测试
	质量模型：功能，性能，兼容，易用，安全
	测功能：验证程序的功能是否满足需求
	测易用性：用户体验性
	测安全
	测兼容性
	测接口：使用代码或工具，验证程序中的接口是否访问正常
	测性能：模拟多人使用软件，查找服务器缺陷

用例优先级按什么分的

| 分类           | 具体问题                                                     |
| -------------- | ------------------------------------------------------------ |
| 个人情况       |                                                              |
|                | 自我介绍                                                     |
|                | 离职原因                                                     |
|                | 职业规划                                                     |
|                | 为何转行                                                     |
|                | 有无培训过                                                   |
|                | 加班态度                                                     |
| 项目情况       |                                                              |
|                | 上家公司简介                                                 |
|                | 项目介绍                                                     |
|                | 负责模块/业务逻辑                                            |
|                | 测试流程                                                     |
|                | 测试工具                                                     |
|                | 测试时长/迭代周期/项目上线一般测试几次                       |
|                | 开发测试配比/几个测试                                        |
|                | 每天写多少用例，一个功能大概写多少用例，一个模块写多少用例   |
|                | 用到了哪些用例设计方法，结合项目举例                         |
|                | 遇到的你认为最不容易解决的问题                               |
|                | 印象深刻的bug，怎么解决的                                    |
|                | 提过的高质量bug                                              |
|                | 遇到不可重现的bug怎么办                                      |
|                | 之前项目上线后有没有遗留bug？                                |
| 测试理论       |                                                              |
|                | 用例要素                                                     |
|                | 缺陷要素                                                     |
|                | 缺陷状态/缺陷流程                                            |
|                | 测试报告                                                     |
|                | 软件生命周期                                                 |
| 现场测试       |                                                              |
|                | 你负责的订单模块的用例是怎么编写的，相关业务逻辑讲一下       |
|                | 货品添加到购物车，那数据库的记录会不会减少？测试用例？货物减少的业务逻辑 |
|                | 一个网站，如何测试                                           |
|                | 一个登陆页面 用户名 密码 口头说测试用例？                    |
|                | 设计从购物车到支付到配送到提交订单流程的测试点               |
|                | 浏览器打开一个页面一起没有显示，你会考虑哪些情况             |
|                | 如果一个项目，必须上线,还有模块没有测完，你作为测试领导该怎么办？ |
|                | 测试日期时间                                                 |
|                | ATM自动取款机测试用例                                        |
|                | 输入三条边，判断三角形测试用例                               |
|                | 微信朋友圈点赞功能点                                         |
|                | 测试电梯/纸杯                                                |
| 与开发关系     |                                                              |
|                | bug提交了，开发未解决，这个项目必须上线 应该怎么办？         |
|                | 如果你提一个bug，开发觉得不是bug该怎么办？                   |
| Linux          |                                                              |
|                | Linux常用20个命令                                            |
| 数据库         |                                                              |
|                | 增删改查                                                     |
|                | 怎么添加一列                                                 |
| 还有什么要问的 |                                                              |
